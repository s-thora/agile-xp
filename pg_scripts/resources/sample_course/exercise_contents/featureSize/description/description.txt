<h2>Objective</h2><p>Add a new feature to the legacy code: the board can be of any size, defined in a configurations file.</p><p>Fist, you should use <em>size</em> variable to represent the size value instead of magic constants in legacy program.&nbsp;As a result, this repeatedly used variable gets a name, which describes its meaning, and it becomes easier to read, maintain and change the code.</p><p>There are techniques for working with legacy code, which respect the properties, functionality and structure of the existing code, no matter how good it is. One of this techniques is called&nbsp;<em>sprout</em>, it uses isolating a new code in an existing one, so existing code is not changed. New code may be tested independently and its influence of the existing functionality is limited and observable. A sprout method, which provides a new functionality, is called withing an existing code. When it is needed to add a sequence of actions and changes, which are related to each other, creating a sprout method may be not enough. In this case a sprout class may be used, with new variables and methods.</p><p>After refactoring, use sprout technique to add a new feature. Configuration files contain one more line for configuring a board size, create sprout methods to read that line and store a size value to the created variable.</p><p>This exercise is provided with new configuration files, which have one more row with size value. You can access them with updated GameConfig utility class.</p><p>Keep the original core structure of the code. You should write own tests so the program would maintain functional and new features would be implemented correctly. The program should pass all your and hidden tests.</p><h3><strong>User stories</strong></h3><ul><li>The board&nbsp;should&nbsp;be of size, defined by a configurations file</li><li>Use <em>size </em>variable to represent the board size</li><li>Board enumeration should be used on printed out playground</li></ul>